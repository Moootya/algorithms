def max_heapify(arr: list, heap_size: int, i: int):
    """
    :param arr: Массив
    :param heap_size: Количество элементов в пирамиде
    :param i: Индекс из выбранного массива (Потенциальный корень подпирамиды)
    :return: Непосредственное преобразование массива в двоичную кучу элементов для указанного индекса
    """

    # Инициализация корня
    largest = i  # O(1)

    # Инициализация левого и правого элемента от значения i
    left = (2 * i) + 1  # O(1)
    right = (2 * i) + 2  # O(1)

    # Существует ли левый дочерний элемент, больший указанного корня?
    if left < heap_size and arr[i] < arr[left]:  # O(1)
        # Если да, то
        largest = left  # O(1)

    # Проверка идет последовательно, так как пирамида заполняется слева-направо
    # => проверять нужно с наибольшим элементов, т.е. с родителем выбранного индекса
    # Существует ли дочерний правый элемент, который больше корня ?
    if right < heap_size and arr[largest] < arr[right]:  # O(1)
        largest = right  # O(1)

    # Если корень изменился, то заменяем корень на больший
    if largest != i:  # O(1)
        arr[i], arr[largest] = arr[largest], arr[i]  # O(1)

        # Рекурсивно вызываем эту же функцию к ее корню
        max_heapify(arr, heap_size, largest)


def build_max_heap(a: list):
    """
    :param a: Список
    :return: Выстраивает из элементом списква невозрастающую пирамиду
    """

    # Для построения невозрастающей пирамиды необходимо идти справа налево
    # Остальные элементы пирамиды будут невозрастающими (тривиальный случай, когда пирамида из 1 элемента)
    for i in range(len(a)//2, -1, -1):  # O(n)
        max_heapify(a, len(a), i)  # O(log2(n))
# Общая оценка, которая не является асимптотически точной - O(n * log2(n)) в худшем случае. O(n) в лучшем


def heap_sort(arr: list):
    """
    :param arr: Список для сортировки
    :return: Сортирует список пирамидалььной сортировкой
    """

    # Построение невозрастающей пирамиды
    build_max_heap(arr)  # O(n)

    # Обход в цикле
    for i in range(len(arr) - 1, 0, -1):

        # Обменять местами максимальный и минимальный элементы пирамиды
        arr[i], arr[0] = arr[0], arr[i]

        # Вызвать корректировку пирамиды для нулевого элемента, который был изменен в предыдущем шаге
        # Уменьшеить размер пирамиды
        max_heapify(arr, i, 0)  # O(log2(n))


if __name__ == '__main__':
    arr = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]

    print(arr)
    heap_sort(arr)
    print(arr)
